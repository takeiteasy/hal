#!/usr/bin/env python3
import os
import re
import urllib.request
from datetime import datetime

GAMECONTROLLERDB_URL = "https://github.com/mdqinc/SDL_GameControllerDB/raw/refs/heads/master/gamecontrollerdb.txt"
GAMEPAD_HEADER = os.path.join(os.path.dirname(__file__), "hal", "gamepad.h")

# Platform mapping from SDL to our identifiers
PLATFORM_MAP = {
    "Windows": "HAL_PLATFORM_WINDOWS",
    "Mac OS X": "HAL_PLATFORM_MACOS", 
    "Linux": "HAL_PLATFORM_LINUX",
    "Android": "HAL_PLATFORM_ANDROID",
    "iOS": "HAL_PLATFORM_IOS",
}

def download_database():
    """Download the gamecontrollerdb.txt file"""
    print(f"Downloading from {GAMECONTROLLERDB_URL}...")
    try:
        with urllib.request.urlopen(GAMECONTROLLERDB_URL, timeout=30) as response:
            return response.read().decode('utf-8')
    except Exception as e:
        print(f"Failed to download: {e}")
        return None

def parse_mappings(content):
    """Parse the gamecontrollerdb.txt and return mappings grouped by platform"""
    mappings = {
        "windows": [],
        "macos": [],
        "linux": [],
        "android": [],
        "ios": [],
    }
    
    for line in content.split('\n'):
        line = line.strip()
        if not line or line.startswith('#'):
            continue
            
        # Extract platform
        platform_match = re.search(r'platform:([^,]+)', line)
        if not platform_match:
            continue
            
        platform = platform_match.group(1).strip().rstrip(',')
        
        # Map to our platform keys
        platform_key = None
        if platform == "Windows":
            platform_key = "windows"
        elif platform == "Mac OS X":
            platform_key = "macos"
        elif platform == "Linux":
            platform_key = "linux"
        elif platform == "Android":
            platform_key = "android"
        elif platform == "iOS":
            platform_key = "ios"
        
        if platform_key:
            # Escape backslashes and quotes for C string
            escaped = line.replace('\\', '\\\\').replace('"', '\\"')
            mappings[platform_key].append(escaped)
    
    return mappings

def generate_mapping_header(mappings):
    """Generate C code for the embedded mappings"""
    
    lines = []
    lines.append("/* Auto-generated by generate_mappings.py - DO NOT EDIT MANUALLY */")
    lines.append(f"/* Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} */")
    lines.append("")
    lines.append("/* SDL GameControllerDB mappings - see https://github.com/mdqinc/SDL_GameControllerDB */")
    lines.append("")
    
    # Generate per-platform mapping arrays
    for platform, entries in mappings.items():
        macro = f"HAL_PLATFORM_{platform.upper()}"
        lines.append(f"#if defined({macro})")
        lines.append(f"static const char *hal_gamepad_builtin_mappings[] = {{")
        for entry in entries:
            lines.append(f'    "{entry}",')
        lines.append("    NULL")
        lines.append("};")
        lines.append(f"static const unsigned int hal_gamepad_builtin_mapping_count = {len(entries)};")
        lines.append(f"#endif /* {macro} */")
        lines.append("")
    
    # Default fallback for unsupported platforms
    lines.append("#if !defined(HAL_PLATFORM_WINDOWS) && !defined(HAL_PLATFORM_MACOS) && \\")
    lines.append("    !defined(HAL_PLATFORM_LINUX) && !defined(HAL_PLATFORM_ANDROID) && !defined(HAL_PLATFORM_IOS)")
    lines.append("static const char *hal_gamepad_builtin_mappings[] = { NULL };")
    lines.append("static const unsigned int hal_gamepad_builtin_mapping_count = 0;")
    lines.append("#endif")
    lines.append("")
    
    return '\n'.join(lines)

def update_gamepad_header(mapping_code):
    """Update gamepad.h with the mapping code between markers"""
    
    begin_marker = "// BEGIN GAMEPAD MAPPINGS"
    end_marker = "// END GAMEPAD MAPPINGS"
    
    with open(GAMEPAD_HEADER, 'r') as f:
        content = f.read()
    
    # Check if markers exist
    if begin_marker not in content:
        # Insert markers and mapping code before the closing #endif
        # Find the position just before the final #endif // HAL_GAMEPAD_HEAD
        insert_pos = content.rfind("#ifdef __cplusplus")
        if insert_pos == -1:
            insert_pos = content.rfind("#endif")
        
        new_content = (
            content[:insert_pos] +
            f"\n{begin_marker}\n" +
            mapping_code +
            f"{end_marker}\n\n" +
            content[insert_pos:]
        )
    else:
        # Replace content between markers
        pattern = re.compile(
            re.escape(begin_marker) + r'.*?' + re.escape(end_marker),
            re.DOTALL
        )
        replacement = f"{begin_marker}\n{mapping_code}{end_marker}"
        new_content = pattern.sub(replacement, content)
    
    with open(GAMEPAD_HEADER, 'w') as f:
        f.write(new_content)
    
    print(f"Updated {GAMEPAD_HEADER}")

def main():
    # Download database
    content = download_database()
    if not content:
        print("Failed to download gamecontrollerdb.txt")
        return 1
    
    # Parse mappings
    mappings = parse_mappings(content)
    
    # Print stats
    total = sum(len(m) for m in mappings.values())
    print(f"Parsed {total} mappings:")
    for platform, entries in mappings.items():
        print(f"  {platform}: {len(entries)}")
    
    # Generate C code
    mapping_code = generate_mapping_header(mappings)
    
    # Update gamepad.h
    update_gamepad_header(mapping_code)
    
    print("Done!")
    return 0

if __name__ == "__main__":
    exit(main())
